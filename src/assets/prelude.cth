while = { |test, body|
  if test() {
    if { {body(); true}(;;loop-cont:cont) }() {
      while test body
    }
  }
}
break = { .loop-cont false }
continue = { .loop-cont true }


function = { |func| func(;;return-cont:cont) }
return = { |var| .return-cont var }


# TODO: 'and' and 'or' currently do not support short circuiting.
and = { |left, right| if left { right } { left } }
or = { |left, right| if left { left } { right } }
not = { |val| if val { false } { true } }


construct = { |func|
  obj = new_object.
  rv = func obj
  seal_object obj
}
# TODO: actually clear this out of the scope or something
new_object = null
seal_object = null


freeze = { |macro|
  k = null
  obj = construct { |o|
    o.k = null
    o.arg = null
  }
  rv = {
    k := cont
    false
  }()
  if (rv) {
    obj.k macro(obj.arg)
  }
  { |arg|
    obj.k = cont
    obj.arg = arg
    k true
  }
}


try = { |body, handler|
  exception-cont = cont
  exception-handler = freeze handler
  { body() }(;;throw:{|e| exception-cont exception-handler(e)})
}
throw = { |e| .throw e }


Dictionary = {

  new_tree_node = {|k, v| construct {|o|
    o.key = k
    o.value = v
    o.left = null
    o.right = null
  }}

  tree_root = null

  update = {|n, k, v| function {
    if (== k n.key) {
      n.value = v
      return 0
    }
    if (< k n.key) {
      if (== n.left null) {
        n.left = new_tree_node k v
        return 0
      }
      update n.left k v
      return 0
    }
    if (== n.right null) {
      n.right = new_tree_node k v
      return 0
    }
    update n.right k v
  }}

  index = {|n, k| function {
    if (== n null) { return null }
    if (== k n.key) { return n.value }
    if (< k n.key) { return (index n.left k) }
    return (index n.right k)
  }}

  has_key? = {|n, k| function {
    if (== n null) { return false }
    if (== k n.key) { return true }
    if (< k n.key) { return (has_key? n.left k) }
    return (has_key? n.right k)
  }}

  each = {|n, f| function {
    if (== n null) { return 0 }
    each n.left f
    f n.key n.value
    each n.right f
  }}

  construct {|obj|
    obj.~update = {|k,v|
      if (tree_root ==. null) {
        tree_root := new_tree_node k v
      } {
        update tree_root k v
      }
    }
    obj.~index = {|i| index tree_root i }
    obj.has_key? = {|i| has_key? tree_root i }
    obj.each = {|f| each tree_root f }

    # this is terrible. let's make lookups O(n)! :(
    obj.copy = {
      new_obj = {}
      each tree_root { |k, v| new_obj[k] = v }
      new_obj
    }

    # this is also terrible. fold anyone? or even better, cached size?
    obj.size = {
      sum = 0
      each tree_root { |k, v| sum := + sum 1 }
      sum
    }
  }
}
